"""Module to create a human readable report for expedited review."""

import argparse
import json
import logging
import os
from datetime import datetime

from docx import Document
from ebird.api import get_taxonomy

from get_reports import ebird_data_access, get_ebird_api_key


def _parse_arguments() -> argparse.Namespace:
    """Parse the command line arguments."""
    arg_parser = argparse.ArgumentParser(
        prog="create_review_document",
        description="Create a human readable report for expedited review.",
    )
    arg_parser.add_argument(
        "--input",
        help="Observations requiring review",
        default="reports/records_to_review.json",
    )

    arg_parser.add_argument(
        "--output",
        help="Observations requiring review",
        default="reports/records_to_review.docx",
    )

    arg_parser.add_argument(
        "--verbose", action="store_true", help="increase verbosity"
    )
    return arg_parser.parse_args()


def _load_observations(file_path: str) -> dict:
    """Load observations from a JSON file."""
    with open(file_path, "rt", encoding="utf-8") as file:
        return json.load(file)


def _create_document(
    ebird_api_key: str, observations: dict, taxonomy: list
) -> Document:
    """Create a Word document based on observations."""
    document = Document()
    _add_document_header(document, observations)
    _iterate_over_species(
        ebird_api_key, document, observations["records"], taxonomy=taxonomy
    )
    return document


LIST_BULLET_STYLE = "List Bullet"


def _add_document_header(document: Document, observations: dict):
    """Add the header section to the document."""
    document.add_heading("DRAFT Records for Expedited Review", 0)
    document.add_paragraph(
        style=LIST_BULLET_STYLE,
        text=f"Dates of observations: {observations['date of observations']}",
    )
    document.add_paragraph(
        style=LIST_BULLET_STYLE,
        text=f"Region: {observations['region']}",
    )
    document.add_paragraph(
        style=LIST_BULLET_STYLE,
        text=f"Dates of report creation: {observations['date of report']}",
    )
    p = document.add_paragraph(
        style=LIST_BULLET_STYLE,
        text="Produced for and by VARCOM (Virginia Avian Records Committee)"
        ", of the VSO (Virginia Society of Ornithology). ",
    )
    p.add_run(
        "https://www.virginiabirds.org/varcom"
    ).hyperlink = "https://www.virginiabirds.org/varcom"
    p = document.add_paragraph(
        style=LIST_BULLET_STYLE,
        text="Automatically generated by VARCOM-get-reports. ",
    )
    p.add_run(
        "https://github.com/gbabineau/VARCOM-get-reports"
    ).hyperlink = "https://github.com/gbabineau/VARCOM-get-reports"


def get_day_number(date_string):
    """
    Converts a date string in YYYY-MM-DD format to the day number of the year.

    Args:
        date_string (str): The date string in "YYYY-MM-DD" format (e.g., "2025-01-20").

    Returns:
        int: The day number of the year (e.g., 20 for Jan 20th, 365 for Dec 31st non-leap year).
    """
    try:
        # Parse the string into a datetime object
        date_object = datetime.strptime(date_string, "%Y-%m-%d")

        # Use the strftime method to get the day of the year (%j)
        # Note: %j returns a zero-padded string, so we convert it to an integer
        day_number_str = date_object.strftime("%j")
        day_number = int(day_number_str)

        return day_number

    except ValueError as e:
        print(f"Error: {e}")
        return None


def _iterate_over_species(
    ebird_api_key: str, document: Document, counties: list, taxonomy: list
):
    """Add records for each species to the document."""
    species_by_county = {}
    for county in counties:
        for record in county["records"]:
            species = record["observation"]["comName"]
            if species not in species_by_county:
                species_by_county[species] = {}
                species_by_county[species]["taxon"] = next(
                    (t for t in taxonomy if t.get("comName") == species), {}
                )
                species_by_county[species]["records"] = []

            species_by_county[species]["records"].append(record)

    for species in sorted(
        species_by_county.keys(),
        key=lambda s: species_by_county[s]["taxon"].get(
            "taxonOrder", float("inf")
        ),
    ):
        sorted_records = sorted(
            species_by_county[species]["records"],
            key=lambda x: (
                x["observation"].get("subnational2Name", ""),
                get_day_number(x["observation"]["obsDt"][:10]),
            ),
        )
        last_species = ""
        for record in sorted_records:
            if record.get("media"):
                current_species = record["observation"]["comName"]
                if current_species != last_species:
                    _add_species_heading(
                        document,
                        current_species,
                        review_species=record.get("review_species", {}),
                    )
                last_species = current_species
                _add_observation_data(
                    ebird_api_key,
                    document,
                    record,
                    species_by_county[species]["taxon"],
                )


def _add_species_heading(
    document: Document, species: str, review_species: dict
):
    """Add a heading and details for a species."""
    document.add_heading(species, level=2)

    if exclude := review_species.get("exclude", []):
        document.add_paragraph(
            f"The species {species} is excluded from review in the following"
            f"counties and groups of counties: {exclude}",
            style="List Bullet",
        )
    if only := review_species.get("only", []):
        document.add_paragraph(
            f"The species {species}: is only reviewed in the following "
            f"counties or groups of counties: {only}",
            style="List Bullet",
        )
    if unique_exclude_notes := review_species.get("uniqueExcludeNotes", None):
        document.add_paragraph(
            "This species has unique Exclude Notes which could not be "
            f"automated. {unique_exclude_notes}",
            style="List Bullet",
        )
    if not exclude and not only and not unique_exclude_notes:
        document.add_paragraph(
            f"The species {species} is reviewable across the entire state.",
            style="List Bullet",
        )


def _add_observation_data(
    ebird_api_key: str, document: Document, record: dict, species_data: dict
):
    """Add a hyperlink for a species record."""
    observation = record["observation"]
    checklist = ebird_data_access.get_checklist_with_retry(
        ebird_api_key, observation=record["observation"]["subId"]
    )
    observer_name = checklist["userDisplayName"]
    locality = checklist["locId"]
    checklist = observation.get("subId", "")
    if checklist == "":
        checklist = observation.get("SubId", "unknown")
    p = document.add_paragraph()
    p.add_run(f"{species_data['comName']}").bold = True
    p.add_run(" (")
    p.add_run(f"{species_data['sciName']}").italic = True
    p.add_run(
        f"): {observation['howMany']}, {locality} "
        f"{observation['subnational2Name']} [ph. {observer_name}] "
        f"{observation['obsDt']};"
        f"https://ebird.org/checklist/{checklist}"
    ).hyperlink = f"https://ebird.org/checklist/{checklist}"


def _save_document(document: Document, output: str):
    """Save the document to a file."""
    if os.path.exists(output):
        os.remove(output)
    document.save(output)


def main():
    """Main function for the app."""
    args = _parse_arguments()

    if args.verbose:
        logging.basicConfig(level=logging.INFO)
    ebird_api_key = get_ebird_api_key.get_ebird_api_key()
    taxonomy = get_taxonomy(ebird_api_key)

    observations = _load_observations(args.input)
    document = _create_document(ebird_api_key, observations, taxonomy=taxonomy)
    _save_document(document, args.output)


if __name__ == "__main__":
    main()
if __name__ == "__main__":
    main()
